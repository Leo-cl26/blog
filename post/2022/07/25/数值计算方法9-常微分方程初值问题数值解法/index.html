
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>数值计算方法:9-常微分方程初值问题数值解法 | Leocl&#39;s blog</title>
    <link rel="stylesheet" href="/www.leocl.space/css/style.css" />
    <link rel="stylesheet" href="/www.leocl.space/css/fonts.css" />
    
    
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Leo-cl26/picture_bed@main/202405191648914.png" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/www.leocl.space/">Home</a></li>
      
      <li><a href="/www.leocl.space/about/">About</a></li>
      
      <li><a href="/www.leocl.space/categories/">Categories</a></li>
      
      <li><a href="/www.leocl.space/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>



<div class="article-meta">
    <h1><span class="title">数值计算方法:9-常微分方程初值问题数值解法</span></h1>
    
    <h2 class="date">2022/07/25</h2>
</div>


<main>
    
    <h3 id="91-引言">9.1 引言</h3>
<p>常微分方程是数学中的一个重要分支，它主要研究未知函数的导数与自变量之间的关系。而常微分方程初值问题数值解法，就是通过数值计算的方法，求出一个微分方程在给定初始值下的解。这个问题在科学、工程、经济等领域中都有广泛的应用，因此其研究具有重要的理论和实际意义。</p>
<h3 id="92-简单的数值方法">9.2 简单的数值方法</h3>
<p>在解决常微分方程初值问题时，最简单的思路就是把微分方程看成一个离散的数值问题。即将自变量分割成若干个等分的小段，并在每个小段上近似求得未知函数的值。这样的数值方法又称为离散化方法。</p>
<p>常用的离散化方法有欧拉法、后退欧拉法、梯形方法和改进欧拉公式等。下面将逐一介绍。</p>
<h4 id="921-欧拉法和后退欧拉法">9.2.1 欧拉法和后退欧拉法</h4>
<p>欧拉法是最简单的数值方法之一，它的基本思路是根据微分方程中的导数来近似求解未知函数的值。具体来说，我们可以将微分方程中的导数用差商来近似，从而得到未知函数的逼近值。</p>
<p>设 $y(t)$ 是常微分方程初值问题的解，$t_n=n\Delta t$，$y_n$ 是 $y(t)$ 在 $t_n$ 处的近似值，则欧拉法的递推公式为：</p>
<p>$y_{n+1}=y_n+\Delta t f(t_n,y_n)$</p>
<p>其中 $f(t,y)$ 表示微分方程右端的函数，也即导数。欧拉法的基本思想就是在每个小段上用该式近似求解 $y(t)$ 的值。</p>
<p>欧拉法的局限性在于其精度较低，误差随着步长的增加而增大。因此，我们可以考虑使用一些更为精细的数值方法来提高精度。</p>
<p>后退欧拉法是一种比欧拉法更为精确的数值方法，它的基本思路是在每个小段上使用微分方程在下一个时间点的导数来近似求解未知函数的值。具体来说，我们可以将微分方程中的导数用差商来近似，从而得到未知函数的逼近值。</p>
<p>设 $y(t)$ 是常微分方程初值问题的解，$t_n=n\Delta t$，$y_n$ 是 $y(t)$ 在 $t_n$ 处的近似值，则后退欧拉法的递推公式为：</p>
<p>$y_{n+1}=y_n+\Delta t f(t_{n+1},y_{n+1})$</p>
<p>其中 $f(t,y)$ 表示微分方程右端的函数，也即导数。后退欧拉法的基本思想就是在每个小段上用该式近似求解 $y(t)$ 的值。</p>
<h4 id="922-梯形方法">9.2.2 梯形方法</h4>
<p>梯形方法是一种更为精确的数值方法，它的基本思路是将微分方程中的导数用两个时间点的平均值来近似。具体来说，我们可以将微分方程中的导数用差商来近似，从而得到未知函数的逼近值。</p>
<p>设 $y(t)$ 是常微分方程初值问题的解，$t_n=n\Delta t$，$y_n$ 是 $y(t)$ 在 $t_n$ 处的近似值，则梯形方法的递推公式为：</p>
<p>$y_{n+1}=y_n+\frac{\Delta t}{2}[f(t_n,y_n)+f(t_{n+1},y_n+\Delta t f(t_n,y_n))]$</p>
<p>其中 $f(t,y)$ 表示微分方程右端的函数，也即导数。梯形方法的基本思想就是在每个小段上用该式近似求解 $y(t)$ 的值。</p>
<h4 id="923-改进欧拉公式">9.2.3 改进欧拉公式</h4>
<p>改进欧拉公式是一种更为精确的数值方法，它的基本思路是在欧拉法的基础上加入了导数在两个时间点上的平均值。具体来说，我们可以将微分方程中的导数用差商来近似，从而得到未知函数的逼近值。</p>
<p>设 $y(t)$ 是常微分方程初值问题的解，$t_n=n\Delta t$，$y_n$ 是 $y(t)$ 在 $t_n$ 处的近似值，则改进欧拉公式的递推公式为：</p>
<p>$y_{n+1}=y_n+\frac{\Delta t}{2}[f(t_n,y_n)+f(t_{n+1},y_n+\Delta t f(t_n,y_n))]$</p>
<p>其中 $f(t,y)$ 表示微分方程右端的函数，也即导数。改进欧拉公式的基本思想就是在每个小段上用该式近似求解 $y(t)$ 的值。</p>
<h4 id="924-单步法的局部截断误差与阶">9.2.4 单步法的局部截断误差与阶</h4>
<p>在上述数值方法中，我们都使用了微分方程中的导数来近似求解未知函数的值。由于这种近似不是完全精确的，因此会产生误差。我们称其为局部截断误差。</p>
<p>单步法的局部截断误差的阶决定了其精度。通常情况下，我们希望这个阶尽可能高，这样可以得到更为精确的数值解。</p>
<p>对于欧拉法、后退欧拉法、梯形方法和改进欧拉公式等单步法，其局部截断误差的阶分别为 $O(\Delta t)$、$O(\Delta t^2)$、$O(\Delta t^2)$ 和 $O(\Delta t^3)$。因此，改进欧拉公式的精度最高，也是应用最为广泛的数值方法之一。</p>
<h3 id="93-龙格-库塔方法">9.3 龙格-库塔方法</h3>
<p>龙格-库塔方法（Runge-Kutta method）是一种常用的数值方法，用于求解常微分方程初值问题。它的主要优点是精度高、稳定性好，因此在工程和科学计算中得到广泛应用。</p>
<h4 id="931-显式龙格-库塔法的一般形式">9.3.1 显式龙格-库塔法的一般形式</h4>
<p>龙格-库塔法是一种迭代法，其基本思路是利用一系列的中间变量来逼近未知函数在下一个时间点的值。具体来说，我们可以将微分方程中的导数用差商来近似，从而得到未知函数的逼近值。</p>
<p>设 $y(t)$ 是常微分方程初值问题的解，$t_n=n\Delta t$，$y_n$ 是 $y(t)$ 在 $t_n$ 处的近似值，则显式龙格-库塔法的一般形式为：</p>
<div>
$\begin{aligned} k_1 &= f(t_n,y_n)\\ k_2 &= f(t_n+c_2\Delta t,y_n+a_{21}k_1\Delta t)\\ k_3 &= f(t_n+c_3\Delta t,y_n+a_{31}k_1\Delta t+a_{32}k_2\Delta t)\\ & \vdots \\ k_s &= f(t_n+c_s\Delta t,y_n+\sum_{i=1}^{s-1}a_{si}k_i\Delta t)\\ y_{n+1} &= y_n+\Delta t\sum_{i=1}^sb_ik_i \end{aligned}$
</div>
其中 $f(t,y)$ 表示微分方程右端的函数，也即导数；$k_i$ 是中间变量；$c_i, a_{ij}$ 和 $b_i$ 是系数。在使用龙格-库塔方法时，我们需要确定这些系数的值。
<h4 id="932-二阶显式r-k方法">9.3.2 二阶显式R-K方法</h4>
<p>二阶显式R-K方法是一种最简单的龙格-库塔方法，它的基本思路是在每个小段上使用微分方程在两个时间点的导数来近似求解未知函数的值。具体来说，我们可以将微分方程中的导数用差商来近似，从而得到未知函数的逼近值。</p>
<p>设 $y(t)$ 是常微分方程初值问题的解，$t_n=n\Delta t$，$y_n$ 是 $y(t)$ 在 $t_n$ 处的近似值，则二阶显式R-K方法的递推公式为：</p>
<div>
$\begin{aligned} k_1 &= f(t_n,y_n)\\ k_2 &= f(t_n+\Delta t,y_n+\Delta t k_1)\\ y_{n+1} &= y_n+\frac{\Delta t}{2}(k_1+k_2) \end{aligned}$
</div>
其中 $f(t,y)$ 表示微分方程右端的函数，也即导数。二阶显式R-K方法的基本思想就是在每个小段上用该式近似求解 $y(t)$ 的值。
<h4 id="933-三阶或四阶显式r-k方法">9.3.3 三阶或四阶显式R-K方法</h4>
<p>三阶或四阶显式R-K方法是一种更为精确的龙格-库塔方法，它的基本思路是在每个小段上使用微分方程在三个或四个时间点的导数来近似求解未知函数的值。具体来说，我们可以将微分方程中的导数用差商来近似，从而得到未知函数的逼近值。</p>
<p>设 $y(t)$ 是常微分方程初值问题的解，$t_n=n\Delta t$，$y_n$ 是 $y(t)$ 在 $t_n$ 处的近似值，则三阶或四阶显式R-K方法的递推公式为：</p>
<div>
$\begin{aligned} k_1 &= f(t_n,y_n)\\ k_2 &= f(t_n+\frac{\Delta t}{2},y_n+\frac{\Delta t}{2} k_1)\\ k_3 &= f(t_n+\Delta t,y_n-\Delta t k_1+2\Delta t k_2)\\ y_{n+1} &= y_n+\frac{\Delta t}{6}(k_1+4k_2+k_3) \end{aligned}$
</div>
或
<div>
$\begin{aligned} k_1 &= f(t_n,y_n)\\ k_2 &= f(t_n+\frac{\Delta t}{2},y_n+\frac{\Delta t}{2} k_1)\\ k_3 &= f(t_n+\frac{\Delta t}{2},y_n+\frac{\Delta t}{2} k_2)\\ k_4 &= f(t_n+\Delta t,y_n+\Delta t k_3)\\ y_{n+1} &= y_n+\frac{\Delta t}{6}(k_1+2k_2+2k_3+k_4) \end{aligned}$
</div>
其中 $f(t,y)$ 表示微分方程右端的函数，也即导数。三阶或四阶显式R-K方法的基本思想就是在每个小段上用该式近似求解 $y(t)$ 的值。
<h4 id="934-变步长的龙格-库塔方法">9.3.4 变步长的龙格-库塔方法</h4>
<p>在实际应用中，我们需要根据所求解的问题和计算机性能等因素来选择合适的步长。如果步长过大，会导致精度降低；如果步长过小，会导致计算量增大，速度变慢。因此，我们需要一种能够自适应调整步长的方法来求解常微分方程初值问题。</p>
<p>变步长的龙格-库塔方法是一种常用的自适应步长方法，其基本思路是根据误差大小来动态地调整步长。具体来说，我们可以利用两个不同阶数的龙格-库塔方法的结果来比较误差大小，从而调整步长和控制精度。</p>
<p>设 $y(t)$ 是常微分方程初值问题的解，$t_n=n\Delta t$，$y_n$ 是 $y(t)$ 在 $t_n$ 处的近似值，则变步长的龙格-库塔方法的基本思路如下：</p>
<ol>
<li>用某个固定步长的R-K方法求解 $y(t)$ 的值，得到 $y_n$ 和 $y_{n+1}$；</li>
<li>使用两种不同阶数的R-K方法分别求解 $y(t)$ 的值，得到 $y_n^{(1)}$、$y_{n+1}^{(1)}$ 和 $y_n^{(2)}$、$y_{n+1}^{(2)}$；</li>
<li>计算误差估计值 $\epsilon=|y_{n+1}^{(1)}-y_{n+1}^{(2)}|$；</li>
<li>根据误差估计值 $\epsilon$ 调整步长，并重新求解 $y(t)$ 的值，直到达到所需精度。</li>
</ol>
<p>其中，步骤 2 和 3 可以使用龙格-库塔方法的三阶和四阶公式。</p>
<p>变步长的龙格-库塔方法的优点在于可以自适应地调整步长，从而保证精度和计算效率。缺点在于实现较为复杂，需要进行大量的计算。</p>
<h3 id="94-单步法的收敛性与稳定性">9.4 单步法的收敛性与稳定性</h3>
<p>在数值求解常微分方程初值问题时，我们通常使用单步法来逼近解的值。然而，不同的单步法具有不同的收敛性和稳定性，这会直接影响到求解的精度和稳定性。因此，我们需要对单步法的收敛性和稳定性进行分析和研究，以便选择合适的数值方法来求解常微分方程初值问题。</p>
<h4 id="941-收敛性和相容性">9.4.1 收敛性和相容性</h4>
<p>收敛性是指当步长 $\Delta t$ 趋向于 $0$ 时，数值解 $y_n$ 逼近真解 $y(t_n)$ 的速度。通常情况下，我们希望所选择的数值方法具有一定的收敛性，以保证求解的精度和可靠性。</p>
<p>相容性是指当步长 $\Delta t$ 趋向于 $0$ 时，数值方法的截断误差 $R_n$ 与步长的关系。具体来说，若数值方法的截断误差满足 $R_n=O(\Delta t^p)$，则称该方法是 $p$ 阶相容的。相容性是收敛性的必要条件，即收敛性需要相容性的支撑。</p>
<h4 id="942-绝对收敛域">9.4.2 绝对收敛域</h4>
<p>稳定性是指当步长 $\Delta t$ 趋向于 $0$ 时，数值方法的舍入误差是否会放大。如果在求解过程中，舍入误差会逐渐放大导致解的不可靠，我们称该方法是不稳定的。因此，我们需要对数值方法的稳定性进行分析和研究。</p>
<p>绝对收敛域是指数值方法在什么范围内的初始值能够保证解的稳定性。对于一些数值方法，其绝对收敛域是有限的，即只有满足某些条件的初始值才能得到稳定的解。而对于一些数值方法，其绝对收敛域是无限的，即任何初始值都能得到稳定的解。</p>
<p>在实际应用中，我们需要选择绝对收敛域足够大的数值方法，以保证求解的稳定性和可靠性。如果所选方法的绝对收敛域很小，我们可以采取一些措施来扩大绝对收敛域，如使用变步长方法或者添加稳定化项等。</p>
<h3 id="95-线性多步法">9.5 线性多步法</h3>
<p>线性多步法是求解常微分方程初值问题的一类数值方法，其公式中包含多个历史步骤的信息，因此也被称为历史多项式法。线性多步法由预测步和校正步组成，预测步使用历史步骤的信息预测下一个步骤的值，校正步使用预测值和历史步骤的信息来修正预测值，以获得更精确的解。线性多步法的一般形式为：</p>
<p>$\sum_{i=0}^{k} a_i y_{n+i} = \Delta t \sum_{i=0}^{k} b_i f_{n+i},\quad n\geq 0,$</p>
<p>其中 $a_i$ 和 $b_i$ 是常数系数，$y_n$ 是数值解，$f_n$ 是待求解函数在点 $(t_n,y_n)$ 处的函数值。</p>
<p>不同的线性多步法具有不同的系数，下面介绍几种常见的线性多步法。</p>
<h4 id="951-线性多步法的一般公式">9.5.1 线性多步法的一般公式</h4>
<p>对于线性多步法，其一般公式可以表示为：</p>
<p>$\sum_{i=0}^{k} a_i y_{n+i} = \Delta t \sum_{i=0}^{k} b_i f_{n+i},\quad n\geq 0,$</p>
<p>其中 $a_i$ 和 $b_i$ 是常数系数，$y_n$ 是数值解，$f_n$ 是待求解函数在点 $(t_n,y_n)$ 处的函数值。</p>
<h4 id="952-阿当姆斯显式与隐式公式">9.5.2 阿当姆斯显式与隐式公式</h4>
<p>阿当姆斯公式是一种线性多步法，最常见的形式是：</p>
<p>$y_{n+2} - y_n = \frac{3}{2}\Delta tf_{n+1} - \frac{1}{2}\Delta tf_n.$</p>
<p>这是一个二阶的公式，其误差项为 $O(\Delta t^3)$。该公式是显式的，因为要求 $y_{n+2}$，只需要已知 $y_{n+1}$ 和 $y_n$ 的值即可，不需要解方程。但是，显式公式的稳定性往往较差。</p>
<p>阿当姆斯公式还有一种隐式的形式：</p>
<p>$-y_{n+2} + 4y_{n+1} - 3y_n = 2\Delta tf_{n+1}.$</p>
<p>这是一个三阶的公式，其误差项为 $O(\Delta t^4)$。该公式是隐式的，因为要求 $y_{n+2}$，需要解一个三元方程，因此计算量较大。但是，隐式公式的稳定性往往较好。</p>
<h4 id="953-米尔尼方法和辛普森方法">9.5.3 米尔尼方法和辛普森方法</h4>
<p>米尔尼方法是一种线性多步法，其一般形式为：</p>
<p>$y_{n+3} - 4y_{n+2} + 3y_{n+1} = \Delta t\left(\frac{23}{12}f_{n+2} - \frac{4}{3}f_{n+1} + \frac{5}{12}f_n\right).$</p>
<p>这是一个三阶的公式，其误差项为 $O(\Delta t^4)$。该公式是隐式的，因为要求 $y_{n+3}$，需要解一个三元方程，因此计算量较大。但是，隐式公式的稳定性往往较好。</p>
<p>辛普森方法是一种线性多步法，其一般形式为：</p>
<p>$\frac{1}{2}y_{n+2} - y_{n+1} + \frac{1}{2}y_n = \frac{\Delta t}{3}\left(f_{n+2} + 4f_{n+1} + f_n\right).$</p>
<p>这是一个二阶的公式，其误差项为 $O(\Delta t^3)$。该公式是显式的，因为要求 $y_{n+2}$，只需要已知 $y_{n+1}$ 和 $y_n$ 的值即可，不需要解方程。但是，显式公式的稳定性往往较差。</p>
<h4 id="954-汉明方法">9.5.4 汉明方法</h4>
<p>汉明方法是一种线性多步法，其一般形式为：</p>
<p>$y_{n+2} - y_n = 2\Delta t f_{n+1} + \frac{1}{3}\left(\Delta t\right)^2\left[f_{n+2} - f_n\right].$</p>
<p>这是一个二阶的公式，其误差项为 $O(\Delta t^3)$。该公式是显式的，因为要求 $y_{n+2}$，只需要已知 $y_{n+1}$ 和 $y_n$ 的值即可，不需要解方程。但是，显式公式的稳定性往往较差。</p>
<h4 id="955-预测-校正方法">9.5.5 预测-校正方法</h4>
<p>预测-校正方法是一种线性多步法，其基本思想是先使用一些历史步骤的信息预测下一个步骤的值，然后再使用预测值和历史步骤的信息来修正预测值，以获得更精确的解。预测-校正方法的一般形式为：</p>
<p>$\sum_{i=0}^{k} a_i y_{n+i} = \Delta t \sum_{i=0}^{k} b_i f_{n+i},\quad n\geq 0,$</p>
<p>其中 $a_i$ 和 $b_i$ 是常数系数，$y_n$ 是数值解，$f_n$ 是待求解函数在点 $(t_n,y_n)$ 处的函数值。</p>
<p>预测-校正方法的具体构造方法有很多种，如 Adams-Bashforth 方法、Adams-Moulton 方法等。</p>
<h4 id="956-构造多步法公式的注记和例">9.5.6 构造多步法公式的注记和例</h4>
<p>构造线性多步法的一般方法是先将待求解的方程转化为一阶形式，然后采用泰勒级数展开的方法，将函数值 $y_{n+i}$ 和导数 $f_{n+i}$ 在点 $(t_n,y_n)$ 处展开，然后进行适当的组合和近似，得到多步法的一般形式。</p>
<p>例如，对于二阶常微分方程 $y&rsquo;&rsquo;=f(t,y,y&rsquo;)$，我们可以将其转化为一阶形式：</p>
<div>
$\begin{cases}y'=z\\ z'=f(t,y,z)\end{cases}.$
</div>
然后，我们可以采用泰勒级数展开的方法，将函数值 $y_{n+i}$ 和导数 $f_{n+i}$ 在点 $(t_n,y_n)$ 处展开，得到：
<div>
$\begin{aligned}y_{n+1}&=y_n+\Delta tz_n+\frac{(\Delta t)^2}{2}z'_n+O((\Delta t)^3)\\ z_{n+1}&=z_n+\Delta tf(t_n,y_n,z_n)+\frac{(\Delta t)^2}{2}f'_n+O((\Delta t)^3)\end{aligned}$
</div>
然后，我们可以将上述式子代入多步法的一般形式中，得到具体的公式。例如，Adams-Bashforth 方法的二阶公式为：
<p>$y_{n+2}=y_{n+1}+\frac{\Delta t}{2}(3f_{n+1}-f_n)+O((\Delta t)^3).$</p>
<p>该公式的预测值为 $y_{n+2}^{(p)}=y_{n+1}+\frac{\Delta t}{2}(3f_{n+1}-f_n)$，校正值为 $y_{n+2}^{(c)}=y_{n+1}+\frac{\Delta t}{12}(5f_{n+2}+8f_{n+1}-f_n)$。</p>
<h3 id="96-线性多步法的收敛性与稳定性">9.6 线性多步法的收敛性与稳定性</h3>
<p>线性多步法的收敛性和稳定性是数值方法的两个重要性质。收敛性是指数值解逐渐趋向于精确解的过程，稳定性是指数值解对初始条件和参数的微小变化具有良好的鲁棒性。本节介绍线性多步法的收敛性和稳定性。</p>
<h4 id="961-相容性和收敛性">9.6.1 相容性和收敛性</h4>
<p>线性多步法的收敛性和相容性是密切相关的。相容性是指数值方法和精确解之间的一致性，即当 $\Delta t\rightarrow 0$ 时，数值解逐渐趋向于精确解。线性多步法的相容性可以通过将精确解 $y(t)$ 的泰勒级数展开与数值解 $y_n$ 的公式相比较来判定。如果数值方法的公式与精确解的泰勒级数展开中的几项一致，则称该方法是相容的。</p>
<p>线性多步法的收敛性是指当 $\Delta t\rightarrow 0$ 时，数值解逐渐趋向于精确解。线性多步法的收敛性可以通过定义截断误差来判定。截断误差是数值解和精确解之间的差异，是数值方法的主要误差来源。截断误差可以通过将精确解 $y(t)$ 的泰勒级数展开到与数值解 $y_n$ 相同的阶数，然后将两者相减得到。</p>
<p>若在 $\Delta t\rightarrow 0$ 的情况下，截断误差趋向于 $0$，则称该方法是收敛的。通常使用局部截断误差和全局截断误差来判定线性多步法的收敛性。局部截断误差是指在一个时间步长内的截断误差，全局截断误差是指在整个时间区间内的截断误差。</p>
<h4 id="962-稳定性和相对稳定性">9.6.2 稳定性和相对稳定性</h4>
<p>线性多步法的稳定性是指数值解对初始条件和参数的微小变化具有良好的鲁棒性。稳定性是数值方法的另一个重要性质，因为当初始条件和参数发生微小变化时，数值解的变化也应该是微小的。线性多步法的稳定性可以通过定义一个增长因子来判断。增长因子是数值解在一个时间步长内的增长率，如果增长因子小于 $1$，则该方法是稳定的。</p>
<p>线性多步法的相对稳定性是指数值解对初始条件和参数的微小变化具有良好的鲁棒性，并且稳定性随时间步长的增加而变化不大。相对稳定性是稳定性的更高级别，通常用于研究刚性问题。刚性问题的数值解具有快速的振荡和缓慢的衰减，因此需要稳定性和相对稳定性都较好的数值方法来求解。</p>
<h3 id="97-一阶方程组与刚性方程组">9.7 一阶方程组与刚性方程组</h3>
<h4 id="971-一阶方程组">9.7.1 一阶方程组</h4>
<p>一阶方程组是指形如下面形式的方程组：</p>
<div>
$\begin{cases}\frac{dy_1}{dt}=f_1(t,y_1,y_2,\cdots,y_n)\\ \frac{dy_2}{dt}=f_2(t,y_1,y_2,\cdots,y_n)\\ \vdots\\ \frac{dy_n}{dt}=f_n(t,y_1,y_2,\cdots,y_n)\end{cases}$
</div>
其中 $y_1,y_2,\cdots,y_n$ 是未知函数，$f_1,f_2,\cdots,f_n$ 是已知函数。一阶方程组可以使用欧拉方法、改进欧拉方法、龙格-库塔方法等数值方法求解。
<h4 id="972-化高阶方程为一阶方程组">9.7.2 化高阶方程为一阶方程组</h4>
<p>高阶常微分方程可以通过变量替换和引入新的未知函数，化为一阶常微分方程组。例如，对于二阶常微分方程 $y&rsquo;&rsquo;=f(t,y,y&rsquo;)$，我们可以将其转化为一阶形式：</p>
<div>
$\begin{cases}y'=z\\ z'=f(t,y,z)\end{cases}.$
</div>
然后，我们可以使用一阶常微分方程的数值方法来求解。
<h4 id="973-刚性方程组">9.7.3 刚性方程组</h4>
<p>刚性方程组是指数值解中存在快速振荡和缓慢衰减的问题，通常是由于方程中存在多个时间尺度。刚性问题是数值计算中的重要问题，因为刚性问题的解可能会因为数值方法的不稳定性而发散。</p>
<p>对于刚性问题，需要使用稳定性和相对稳定性较好的数值方法来求解。常用的数值方法包括 Rosenbrock 方法、BDF 方法、DIRK 方法等。此外，还可以使用隐式方法、分裂算子方法等技术来求解刚性问题。</p>

</main>


  <footer>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '\\[', right: '\\]', display: true},   
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},  
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>

  
  <hr/>
  © <a href="http://www.leocl.space/">Leocl</a> 2022 &ndash; 2024 | <a href="https://github.com/Leo-cl26">Github</a> | <a href="https://www.zhihu.com/people/mmtumr">ZhiHu</a>
  
  </footer>
  </body>
</html>

<script src="/www.leocl.space/js/clipboard.js"></script>





