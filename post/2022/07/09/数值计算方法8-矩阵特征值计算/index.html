
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>数值计算方法:8-矩阵特征值计算 | Leocl&#39;s blog</title>
    <link rel="stylesheet" href="/blog/css/style.css" />
    <link rel="stylesheet" href="/blog/css/fonts.css" />
    
    
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Leo-cl26/picture_bed@main/202405191648914.png" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/blog/">Home</a></li>
      
      <li><a href="/blog/about/">About</a></li>
      
      <li><a href="/blog/categories/">Categories</a></li>
      
      <li><a href="/blog/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>



<div class="article-meta">
    <h1><span class="title">数值计算方法:8-矩阵特征值计算</span></h1>
    
    <h2 class="date">2022/07/09</h2>
</div>


<main>
    
    <h3 id="81-特征值性质和估计">8.1. 特征值性质和估计</h3>
<h4 id="811-特征值问题及其性质">8.1.1. 特征值问题及其性质</h4>
<p>定义：设$A$是$n$阶方阵，$\lambda$是一个数，如果存在一个非零向量$x$使得$Ax=\lambda x$，则称$\lambda$是$A$的特征值，$x$是对应于特征值$\lambda$的特征向量。</p>
<p>特征值问题是求解$Ax=\lambda x$的$\lambda$和$x$的问题。特征值问题是矩阵计算中最重要的问题之一，具有广泛的应用背景。例如，特征值和特征向量可以用于谱聚类、主成分分析和矩阵对角化等领域。</p>
<p>特征值问题的另一个重要性质是：对于一个$n$阶方阵，它的特征值个数等于$n$。这个性质被称为代数重数定理。如果$\lambda$是$A$的特征值，并且对应于$\lambda$的特征向量有$k$个，那么称$\lambda$的代数重数为$k$。代数重数是特征值问题中的另一个重要概念。</p>
<p>特征值问题还有一个重要性质：一个$n$阶方阵$A$是可对角化的当且仅当它的$n$个特征向量线性无关。这个性质是特征值问题的一个重要应用。</p>
<h4 id="812-特征值估计与扰动">8.1.2. 特征值估计与扰动</h4>
<p>特征值的计算通常需要使用数值方法。特征值估计和扰动是两种常见的数值方法。</p>
<p>特征值估计是指在一定误差范围内估计特征值的值。常用的特征值估计方法包括幂法和反幂法。</p>
<p>特征值扰动是指在特征值计算过程中引入一些扰动，以便加速特征值的计算。常用的特征值扰动方法包括Wielandt迭代和QR迭代。</p>
<h3 id="82-幂法与反幂法">8.2. 幂法与反幂法</h3>
<h4 id="821-幂法">8.2.1. 幂法</h4>
<p>幂法是求解特征值和对应特征向量的一种迭代方法。幂法的基本思想是：通过不断地乘以矩阵$A$的向量序列$x_0, x_1, x_2, &hellip;$来逼近$A$的一个特征向量。幂法中的迭代公式如下：</p>
<p>$$
x_{k+1}=\frac{Ax_k}{|Ax_k|}
$$</p>
<p>其中，$x_0$是一个任意的列向量，$|\cdot|$表示向量的二范数。</p>
<p>幂法的收敛性取决于矩阵$A$的特征值的大小关系。具体地，如果$A$的特征值按绝对值从大到小排序为$|\lambda_1|\ge|\lambda_2|\ge&hellip;\ge|\lambda_n|$，那么幂法产生的向量序列满足：</p>
<p>$$
\lim_{k\to\infty}\frac{x_{k+1}}{x_k}=\frac{v_1}{|v_1|}
$$</p>
<p>其中，$v_1$是$A$的模长最大的特征向量。因此，幂法可以用于求解模长最大的特征值和对应的特征向量。</p>
<h4 id="822-加速方法">8.2.2. 加速方法</h4>
<p>幂法的缺点是收敛速度很慢。为了加速幂法的收敛，可以使用以下两种加速方法：</p>
<ol>
<li>反迭代：将幂法迭代公式中的$A$替换为$(A-\mu I)^{-1}$，其中$\mu$是一个与$v_1$相近的数。这样可以加速收敛速度，并且可以通过选择不同的$\mu$来求解不同的特征向量。</li>
<li>QZ迭代：将矩阵$A$相似变换为一个拟三角形矩阵，然后使用幂法对拟三角形矩阵进行迭代。这种方法可以加速收敛速度，并且可以同时求解多个特征向量。</li>
</ol>
<h4 id="823-反幂法">8.2.3. 反幂法</h4>
<p>反幂法是求解特征值和对应特征向量的一种迭代方法。反幂法的基本思想是：通过不断地求解线性方程组$(A-\mu I)x_{k+1}=y_k$来逼近$A$的一个特征向量。反幂法中的迭代公式如下：</p>
<p>$$
x_{k+1}=(A-\mu I)^{-1}y_k
$$</p>
<p>其中，$y_k$是一个任意的列向量，$\mu$是一个与$v_1$相近的数。</p>
<p>反幂法的收敛性取决于矩阵$A$的特征值的大小关系。具体地，如果$A$的特征值按绝对值从大到小排序为$|\lambda_1|&gt;|\lambda_2|\ge&hellip;\ge|\lambda_n|$，那么反幂法产生的向量序列满足：</p>
<p>$$
\lim_{k\to\infty}\frac{x_k}{\lambda_1^k}=\frac{v_1}{|v_1|}
$$</p>
<p>其中，$v_1$是$A$的模长最大的特征向量。因此，反幂法可以用于求解模长最小的特征值和对应的特征向量。</p>
<h3 id="83-正交变换与矩阵分解">8.3. 正交变换与矩阵分解</h3>
<p>在矩阵计算中，正交变换和矩阵分解是非常重要的概念和工具。本章将介绍豪斯赫尔德变换、吉文斯变换、QR分解和舒尔分解等内容。</p>
<h4 id="831-豪斯赫尔德变换">8.3.1. 豪斯赫尔德变换</h4>
<p>豪斯赫尔德变换（Householder transformation）是一种常见的正交变换。豪斯赫尔德变换可以将一个$n$维向量$x$变换为一个$n$维向量$y$，使得$y$的前$m$个分量等于$x$的前$m$个分量，而$y$的后$n-m$个分量为$0$。</p>
<p>豪斯赫尔德变换的基本思想是：构造一个对称正交矩阵$P$，使得$Px=y$，其中$x$和$y$是两个$n$维向量。为了构造矩阵$P$，可以首先选取一个$n$维单位向量$v$，然后构造矩阵$P=I-2vv^T$，其中$I$是$n$阶单位矩阵。这样，矩阵$P$就可以将向量$x$映射到向量$y$，并且使得$y$的前$m$个分量等于$x$的前$m$个分量，而$y$的后$n-m$个分量为$0$。</p>
<p>豪斯赫尔德变换可以用于矩阵的QR分解和线性方程组的求解等问题。</p>
<h4 id="832-吉文斯变换">8.3.2. 吉文斯变换</h4>
<p>吉文斯变换（Givens rotation）是一种常见的正交变换。吉文斯变换可以将一个$n$维向量$x$变换为一个$n$维向量$y$，使得$y$的第$i$个分量等于$x$的第$i$个分量和第$j$个分量的线性组合，而$y$的其他分量与$x$的相同。</p>
<p>吉文斯变换的基本思想是：构造一个对称正交矩阵$G$，使得$Gx=y$，其中$x$和$y$是两个$n$维向量。为了构造矩阵$G$，可以首先选取一个$n$维单位向量$e_i$和$e_j$，然后构造矩阵$G$，使得$Ge_i$和$Ge_j$分别等于$c_ie_i+s_je_j$和$-s_ie_i+c_je_j$，其中$c_i$和$s_j$是两个满足$c_i^2+s_i^2=1$和$c_j^2+s_j^2=1$的实数。这样，矩阵$G$就可以将向量$x$映射到向量$y$，并且使得$y$的第$i$个分量等于$x$的第$i$个分量和第$j$个分量的线性组合，而$y$的其他分量与$x$的相同。</p>
<p>吉文斯变换可以用于矩阵的QR分解和线性方程组的求解等问题。</p>
<h4 id="833-矩阵的qr分解与舒尔分解">8.3.3. 矩阵的QR分解与舒尔分解</h4>
<p>矩阵的QR分解是将一个$n$阶矩阵$A$分解为一个正交矩阵$Q$和一个上三角矩阵$R$的乘积$A=QR$的过程。QR分解可以用于求解线性方程组、最小二乘问题和特征值问题等问题。</p>
<p>QR分解的基本思想是：将矩阵$A$通过一系列正交变换$Q_1,Q_2,&hellip;,Q_k$变换为一个上三角矩阵$R$，即$A=Q_1Q_2&hellip;Q_kR$。其中，每个正交变换$Q_i$可以通过豪斯赫尔德变换或吉文斯变换等方法得到。最终得到的矩阵$R$就是$A$的QR分解中的上三角矩阵，而矩阵$Q=Q_1Q_2&hellip;Q_k$就是$A$的QR分解中的正交矩阵。</p>
<p>舒尔分解是将一个$n$阶矩阵$A$分解为一个上三角矩阵$U$和一个下三角矩阵$L$的乘积$A=LU$的过程。舒尔分解可以用于求解特征值问题和矩阵的对角化等问题。</p>
<p>舒尔分解的基本思想是：通过一系列正交变换$Q_1,Q_2,&hellip;,Q_k$将矩阵$A$变换为一个上三角矩阵$U$，即$A=Q_1Q_2&hellip;Q_kU$。然后，通过对$U$进行对角化，得到矩阵$U$的对角线上的元素就是矩阵$A$的特征值，而矩阵$Q=Q_1Q_2&hellip;Q_k$就是矩阵$A$的特征向量组成的正交矩阵。</p>
<h4 id="834-用正交相似变换约化一般矩阵为上海森伯格矩阵">8.3.4. 用正交相似变换约化一般矩阵为上海森伯格矩阵</h4>
<p>正交相似变换是一种保持矩阵相似的变换。正交相似变换可以将一个$n$阶矩阵$A$通过一个正交矩阵$Q$的相似变换变换为一个相似于$A$的矩阵$B=Q^{-1}AQ$。正交相似变换可以用于矩阵的相似对角化等问题。</p>
<p>将一个$n$阶矩阵$A$通过正交相似变换变换为上海森伯格矩阵（Hessenberg matrix）是一种常见的方法。上海森伯格矩阵是一种类似于上三角矩阵的矩阵，但是它的下三角元素只有一条对角线非零。</p>
<p>将一个$n$阶矩阵$A$通过正交相似变换变换为上海森伯格矩阵的基本思想是：通过一系列豪斯赫尔德变换将矩阵$A$转化为一个上海森伯格矩阵$H$，即$H=Q^{-1}AQ$，其中$Q$是一系列豪斯赫尔德变换矩阵的乘积。这个过程可以通过Householder-QR分解实现。上海森伯格矩阵可以用于求解特征值和矩阵对角化等问题。</p>
<h3 id="84-qr方法">8.4. QR方法</h3>
<p>QR方法是一种求解特征值和特征向量的数值方法。QR方法通过将一个矩阵迭代地分解为一个正交矩阵$Q$和一个上三角矩阵$R$的乘积，从而逐步逼近矩阵的特征值和特征向量。</p>
<h4 id="841-qr算法">8.4.1. QR算法</h4>
<p>QR算法是QR方法的一种基本形式。QR算法的基本思想是：将一个$n$阶矩阵$A$迭代地分解为一个正交矩阵$Q$和一个上三角矩阵$R$的乘积，即$A^{(k)}=Q^{(k)}R^{(k)}$，然后将$R^{(k)}Q^{(k)}$作为下一步的矩阵$A^{(k+1)}$，继续迭代这个过程，直到矩阵$A^{(k)}$收敛为一个上三角矩阵。</p>
<p>QR算法的具体步骤如下：</p>
<ol>
<li>将矩阵$A$分解为$A=QR$，其中$Q$是$n$阶正交矩阵，$R$是$n$阶上三角矩阵。</li>
<li>计算$A_1=RQ$，将$A_1$分解为$A_1=Q_1R_1$，其中$Q_1$是$n$阶正交矩阵，$R_1$是$n$阶上三角矩阵。</li>
<li>计算$A_2=R_1Q_1$，将$A_2$分解为$A_2=Q_2R_2$，其中$Q_2$是$n$阶正交矩阵，$R_2$是$n$阶上三角矩阵。</li>
<li>重复步骤2和步骤3，直到$A_k=Q_kR_k$成为一个上三角矩阵。这时，矩阵$A_k$的对角线上的元素就是矩阵$A$的特征值，而矩阵$Q_k$的列向量就是矩阵$A$的特征向量。</li>
</ol>
<p>QR算法的收敛性是保证的，即经过有限步迭代，QR算法可以将任何一个矩阵转化为一个上三角矩阵，并且上三角矩阵的对角线元素就是矩阵的特征值。</p>
<h4 id="842-带原点位移的qr方法">8.4.2. 带原点位移的QR方法</h4>
<p>带原点位移的QR方法是QR算法的一种改进形式。带原点位移的QR方法的基本思想是：在QR算法的每一步中，通过添加一个位移$\mu$来加速QR分解的收敛速度。具体地，带原点位移的QR方法的迭代公式为：</p>
<p>$A^{(k)}-\mu I=Q^{(k)}R^{(k)}$</p>
<p>$A^{(k+1)}=R^{(k)}Q^{(k)}+\mu I$</p>
<p>其中，$\mu$是一个实数位移，$I$是$n$阶单位矩阵。带原点位移的QR方法将矩阵$A^{(k)}$和位移$\mu$的线性组合分解为一个正交矩阵$Q^{(k)}$和一个上三角矩阵$R^{(k)}$的乘积，然后将$R^{(k)}Q^{(k)}$加上位移$\mu I$作为下一步的矩阵$A^{(k+1)}$。</p>
<p>带原点位移的QR方法可以加速QR算法的收敛速度，并且可以解决QR算法中出现的Wilkinson shift现象。Wilkinson shift是指QR算法中，在计算下一个迭代矩阵的过程中，对角线元素的振荡现象。带原点位移的QR方法通过添加一个位移来消除Wilkinson shift现象，从而提高QR算法的收敛速度。</p>
<h4 id="843-用单步qr方法计算上海森伯格矩阵的特征值">8.4.3. 用单步QR方法计算上海森伯格矩阵的特征值</h4>
<p>上海森伯格矩阵是一种特殊的矩阵，它的下三角元素只有一条对角线非零。用单步QR方法计算上海森伯格矩阵的特征值是一种常见的问题。</p>
<p>用单步QR方法计算上海森伯格矩阵的特征值的基本思想是：通过豪斯赫尔德变换将上海森伯格矩阵转化为一个上三角矩阵，然后利用QR算法计算上三角矩阵的特征值。</p>
<p>具体地，用单步QR方法计算上海森伯格矩阵的特征值的步骤如下：</p>
<ol>
<li>将上海森伯格矩阵$H$通过豪斯赫尔德变换转化为一个上三角矩阵$T$，即$H=Q^T T Q$，其中$Q$是一系列豪斯赫尔德变换矩阵的乘积，$T$是一个上三角矩阵。</li>
<li>利用QR算法计算上三角矩阵$T$的特征值。</li>
</ol>
<p>用单步QR方法计算上海森伯格矩阵的特征值可以通过Householder-QR分解实现。</p>
<h4 id="844-双步qr算法隐式qr算法">8.4.4. 双步QR算法（隐式QR算法）</h4>
<p>双步QR算法（隐式QR算法）是QR算法的一种改进形式。双步QR算法通过隐式地计算QR分解来加速QR算法的收敛速度。</p>
<p>双步QR算法的基本思想是：将QR分解的计算和矩阵乘法的计算结合起来，通过隐式地计算QR分解来加速QR算法的收敛速度。具体地，双步QR算法的步骤如下：</p>
<ol>
<li>对矩阵$A$进行Householder-QR分解，得到$A=QR$，其中$Q$是$n$阶正交矩阵，$R$是$n$阶上三角矩阵。</li>
<li>计算$B=RQ$，即将上三角矩阵$R$和正交矩阵$Q$相乘得到矩阵$B$。</li>
<li>对$B$进行QR分解，得到$B=Q_1R_1$，其中$Q_1$是$n$阶正交矩阵，$R_1$是$n$阶上三角矩阵。</li>
<li>计算$A_1=R_1Q_1$，即将上三角矩阵$R_1$和正交矩阵$Q_1$相乘得到矩阵$A_1$。</li>
<li>重复步骤2到步骤4，直到矩阵$A_k$收敛为一个上三角矩阵。这时，矩阵$A_k$的对角线上的元素就是矩阵$A$的特征值</li>
</ol>

</main>


  <footer>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '\\[', right: '\\]', display: true},   
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},  
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>

  
  <hr/>
  © <a href="https://leo-cl26.github.io/blog/">Leocl</a> 2022 &ndash; 2024 | <a href="https://github.com/Leo-cl26">Github</a> | <a href="https://www.zhihu.com/people/mmtumr">ZhiHu</a>
  
  </footer>
  </body>
</html>

<script src="/blog/js/clipboard.js"></script>





