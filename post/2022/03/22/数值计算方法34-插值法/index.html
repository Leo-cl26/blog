
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>数值计算方法:34-插值法 | Leocl&#39;s blog</title>
    <link rel="stylesheet" href="/blog/css/style.css" />
    <link rel="stylesheet" href="/blog/css/fonts.css" />
    
    
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Leo-cl26/picture_bed@main/202405191648914.png" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/blog/">Home</a></li>
      
      <li><a href="/blog/about/">About</a></li>
      
      <li><a href="/blog/categories/">Categories</a></li>
      
      <li><a href="/blog/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>



<div class="article-meta">
    <h1><span class="title">数值计算方法:34-插值法</span></h1>
    
    <h2 class="date">2022/03/22</h2>
</div>


<main>
    
    <h3 id="41-数值积分概论">4.1. 数值积分概论</h3>
<h4 id="411-数值积分的基本思想">4.1.1. 数值积分的基本思想</h4>
<p>设 $[a,b]$ 为积分区间，$x_0=a,x_1,x_2,\cdots,x_n=b$ 为区间的 $n+1$ 个分点，将积分区间划分为 $n$ 个小间 $[x_{k-1},x_k]$，则积分的近似值可以表示为：</p>
<p>$$\int_{a}^{b} f(x) dx \approx \sum_{k=1}^{n} \int_{x_{k-1}}^{x_k} f(x) dx$$</p>
<p>对于每个小区间 $[x_{k-1},x_k]$，可以采用近似公式来计算积分值，例如梯形公式、辛普森公式等，积分的近似值为：</p>
<p>$$\int_{a}^{b} f(x) dx \approx \sum_{k=1}^{n} \int_{x_{k-1}}^{x_k} P(x) dx$$</p>
<p>其中 $P(x)$ 为取代 $f(x)$ 的多项式函数，其次数和系数由近似公式确定，例如梯形公式中 $P(x)$ 为一次多项式，辛普森公式中 $P(x)$ 为二次多项式。</p>
<h4 id="412-代数精度的概念">4.1.2. 代数精度的概念</h4>
<p>数值积分的代数精度是指采用某个近似公式计算积分时，所得到的积分值与精确积分值之差的最高阶导数有关。设 $I(f)$ 为精确积分值，$I_n(f)$ 为采用 $n$ 阶近似公式计算得到的积分值，则其代数精度为 $p$ 当且仅当存在一个正整数 $m$，使得对于所有 $f(x) \in C^{m+1}[a,b]$，有：</p>
<p>$$I(f) - I_n(f) = O(h^{p+m})$$</p>
<p>其中 $h$ 为区间划分的最大长度。</p>
<h4 id="413-插值型的求积公式">4.1.3. 插值型的求积公式</h4>
<p>插值型的求积公式采用插值多项式 $P(x)$ 来代替被积函数 $f(x)$，然后计算插值多项式在积分区间上的积分值。例如，梯形公式和辛普森公式就是插值型的求积公式。</p>
<p>梯形公式的插值多项式为：</p>
<p>$$P(x) = \frac{f(x_{k-1}) + f(x_k)}{2} + \frac{f&rsquo;&rsquo;(\xi)}{12}(x-x_{k-1})(x-x_k)$$</p>
<p>其中 $\xi \in (x_{k-1},x_k)$，积分的近似值为：</p>
<p>$$\int_{x_{k-1}}^{x_k} f(x) dx \approx \frac{f(x_{k-1}) + f(x_k)}{2}(x_k - x_{k-1})$$</p>
<p>辛普森公式的插值多项式为：</p>
<p>$$P(x) = \frac{f(x_{k-1}) + 4f(x_{k-1}+h) + f(x_k)}{6} - \frac{f^{(4)}(\xi)}{2880}h^4$$</p>
<p>其中 $\xi \in (x_{k-1},x_k)$，积分的近似值为：</p>
<p>$$\int_{x_{k-1}}^{x_k} f(x) dx \approx \frac{f(x_{k-1}) + 4f(x_{k-1}+h) + f(x_k)}{6}(x_k - x_{k-1})$$</p>
<h4 id="414-求积公式的余项">4.1.4. 求积公式的余项</h4>
<p>求积公式的余项是指采用某个近似公式计算得到的积分值与精确积分值之差。对于插值型的求积公式，其余项可以通过泰勒公式推导得到。</p>
<p>例如，对于梯形公式，其余项为：</p>
<p>$$R(f) = -\frac{h^3}{12}f&rsquo;&rsquo;(\xi)$$</p>
<p>其中 $\xi \in (a,b)$，$h$ 为区间划分的长度。</p>
<p>对于辛普森公式，其余项为：</p>
<p>$$R(f) = -\frac{h^5}{2880}f^{(4)}(\xi)$$</p>
<p>其中 $\xi \in (a,b)$，$h$ 为区间划分的长度。</p>
<h4 id="415-求积公式的收敛性与稳定性">4.1.5. 求积公式的收敛性与稳定性</h4>
<p>求积公式的收敛性是指采用某个近似公式计算得到的积分值随着区间划分的细化而趋近于精确积分值的性质。求积公式的稳定性是指积分值对于输入数据的微小变化具有鲁棒性的性质。</p>
<ol>
<li>收敛性</li>
</ol>
<p>求积公式的收敛性可以用以下公式进行表达：</p>
<p>$$\lim_{n\to\infty}\left|\int_a^bf(x)dx-\sum_{i=1}^n\omega_if(x_i)\right|=0$$</p>
<p>其中，$\int_a^bf(x)dx$ 为真实定积分值，$\sum_{i=1}^n\omega_if(x_i)$ 为求积公式的近似值，$n$ 为离散化步数，$f(x_i)$ 为被积函数在离散点 $x_i$ 处的函数值，$\omega_i$ 为权重系数。如果上述公式成立，则求积公式具有收敛性。</p>
<ol start="2">
<li>稳定性</li>
</ol>
<p>求积公式的稳定性可以用以下公式进行表达：</p>
<p>$$\Delta=\left|\int_a^bf(x)dx-\sum_{i=1}^n\omega_if(x_i)\right|$$</p>
<p>其中，$\int_a^bf(x)dx$ 为真实定积分值，$\sum_{i=1}^n\omega_if(x_i)$ 为求积公式的近似值，$\Delta$ 为二者之间的误差。如果 $\Delta$ 对离散化步数 $n$ 的变化不敏感，则求积公式具有稳定性。</p>
<p>对于插值型的求积公式，其收敛性和稳定性与插值多项式的性质密切相关。一般来说，插值多项式次数越高，求积公式的代数精度越高，但同时也会导致求积公式的稳定性下降。</p>
<h3 id="42-牛顿-科特斯公式">4.2. 牛顿-科特斯公式</h3>
<p>牛顿-科特斯公式是一类基于插值多项式的求积公式，其基本思想是采用多项式插值的方法来逼近被积函数，然后利用积分的线性性质将积分转化为求和的形式。</p>
<h4 id="421-科特斯系数与辛普森公式">4.2.1. 科特斯系数与辛普森公式</h4>
<p>科特斯系数是一组常数，用于构造牛顿-科特斯公式；科特斯系数可以通过拉格朗日插值多项式来推导得到。假设我们要用 $n$ 个点 $x_0,x_1,&hellip;,x_n$ 来进行区间 $[a,b]$ 上的数值积分，其中 $x_0=a$，$x_n=b$。我们可以先通过拉格朗日插值多项式求出一个 $n-1$ 次多项式 $f(x)$，使得 $f(x_i)=y_i$，其中 $y_i$ 是对应$x_i$的函数值。那么在区间 $[a,b]$ 上积分 $f(x)$ 的结果可以表示为：</p>
<p>$$
\int_{a}^{b}f(x)dx=\int_{a}^{b}L_n(x)f(x)dx
$$</p>
<p>其中 $L_n(x)$ 是拉格朗日插值多项式的基函数，它可以表示为：</p>
<p>$$
L_n(x)=\prod_{i=0,i\neq j}^{n}\frac{x-x_i}{x_j-x_i}
$$</p>
<p>接下来，我们需要确定每个基函数 $L_i(x)$ 对应的加权系数，即科特斯系数 $C_i$。根据牛顿-科特斯公式的思想，我们希望每个点的函数值对积分的贡献应该是不同的，因此我们需要为每个基函数分配一个不同的加权系数。通过对 $L_n(x)$ 在区间 $[a,b]$ 上进行积分，我们可以得到：</p>
<p>$$
\int_{a}^{b}L_n(x)dx=\frac{(-1)^n}{(n!)^2}\int_{a}^{b}\prod_{i=0}^{n}(x-x_i)^2dx
$$</p>
<p>因此，我们可以得到科特斯系数的通式：</p>
<p>$$
C_i=(-1)^{n-i}\frac{(n!)^2}{i!(n-i)!(2n-2i+1)}
$$</p>
<p>其中，$i=0,1,&hellip;,n$。这个通式可以用来计算任意 $n$ 阶的牛顿-科特斯公式的加权系数。通过将基函数和科特斯系数带入积分公式，就可以得到牛顿-科特斯公式的具体形式。</p>
<p>例如，辛普森公式就是一种基于科特斯系数构造的牛顿-科特斯公式，其插值多项式为：</p>
<p>$$P(x) = \frac{f(x_{k-1}) + 4f(x_{k-1}+h) + f(x_k)}{6}$$</p>
<p>其中 $h=\frac{b-a}{2}$，积分的近似值为：</p>
<p>$$\int_{a}^{b} f(x) dx \approx \frac{h}{3}(f(a) + 4f(a+h) + f(b))$$</p>
<h4 id="422-偶阶求积公式的代数精度">4.2.2. 偶阶求积公式的代数精度</h4>
<p>偶阶求积公式是指采用偶次多项式进行插值的求积公式，例如梯形公式和辛普森公式都是偶阶求积公式。对于偶阶求积公式，其代数精度可以通过以下定理得到：</p>
<p>设 $I(f)$ 为精确积分值，$I_n(f)$ 为采用 $n$ 阶偶阶求积公式计算得到的积分值，则 $I(f) - I_n(f) = O(h^{n+2})$。</p>
<h4 id="423-辛普森公式的余项">4.2.3. 辛普森公式的余项</h4>
<p>辛普森公式的余项可以通过对插值多项式的二阶导数进行估计得到。设 $f(x)$ 在 $[a,b]$ 上具有四阶连续导数，则有：</p>
<p>$$R(f) = -\frac{b-a}{180}h^4f^{(4)}(\xi)$$</p>
<p>其中 $\xi \in (a,b)$，$h=\frac{b-a}{2}$。辛普森公式的余项与区间长度的四次方成正比，因此当区间长度足够小时，辛普森公式的精度较高。</p>
<h2 id="43-复合求积公式">4.3. 复合求积公式</h2>
<p>在实际应用中，我们常常需要对一个函数在一个比较大的区间上进行积分，此时单纯的使用梯形法或者辛普森法可能会导致精度不够，因此需要使用复合求积公式。</p>
<h3 id="431-复合梯形公式">4.3.1. 复合梯形公式</h3>
<p>复合梯形公式的思路是将整个区间分成若干个小区间，对每个小区间使用梯形公式进行积分，最终将所有小区间的积分值相加得到整个区间的积分值。</p>
<p>设 $f(x)$ 是我们需要积分的函数，$[a,b]$ 是我们要积分的区间，将区间 $[a,b]$ 分成 $n$ 个小区间，每个小区间的长度为 $h=\frac{b-a}{n}$，则可以得到复合梯形公式的计算公式为：</p>
<p>$$
\int_a^b f(x)dx \approx \frac{h}{2} \left[ f(a) + 2\sum_{i=1}^{n-1} f(a+ih) + f(b) \right]
$$</p>
<h3 id="432-复合辛普森求积公式">4.3.2. 复合辛普森求积公式</h3>
<p>复合辛普森求积公式的思路与复合梯形公式类似，也是将整个区间分成若干个小区间，对每个小区间使用辛普森公式进行积分，最终将所有小区间的积分值相加得到整个区间的积分值。</p>
<p>设 $f(x)$ 是我们需要积分的函数，$[a,b]$ 是我们要积分的区间，将区间 $[a,b]$ 分成 $n$ 个小区间，每个小区间的长度为 $h=\frac{b-a}{n}$，则可以得到复合辛普森求积公式的计算公式为：</p>
<p>$$
\int_a^b f(x)dx \approx \frac{h}{3} \left[ f(a) + 4\sum_{i=1}^{\frac{n}{2}} f(a+(2i-1)h) + 2\sum_{i=1}^{\frac{n}{2}-1} f(a+2ih) + f(b) \right]
$$</p>
<h2 id="44-龙贝格求积公式">4.4. 龙贝格求积公式</h2>
<p>龙贝格求积公式是一种基于梯形法的递推外推算法，可以在保持一定精度的前提下大大提高计算效率。</p>
<h3 id="441-梯形法的递推化">4.4.1. 梯形法的递推化</h3>
<p>梯形法的计算公式为：</p>
<p>$$
\int_a^b f(x)dx \approx \frac{b-a}{2} \left[ f(a) + f(b) \right]
$$</p>
<p>我们可以将梯形法的计算公式写成一个递推的形式：</p>
<p>$$
T_{i,0} = \frac{b-a}{2} \left[ f(a) + f(b) \right] \
T_{i,j} = \frac{1}{2} T_{i,j-1} + \frac{b-a}{2^j} \sum_{k=1}^{2^{j-1}} f(a+(2k-1)\frac{b-a}{2^j})
$$</p>
<p>其中 $T_{i,j}$ 表示将区间 $[a,b]$ 分成 $2^j$ 个小区间，对第 $i$ 个小区间使用梯形法所得到的积分值。</p>
<h3 id="442-外推技巧">4.4.2. 外推技巧</h3>
<p>龙贝格算法的关键在于外推技巧，将不同阶数的递推公式组合起来进行外推，从而提高计算精度。</p>
<p>设 $R_{i,j}$ 表示使用 $T_{i,j}$ 和 $T_{i-1,j-1}$ 计算得到的积分值，即：</p>
<p>$$
R_{i,j} = \frac{4^j T_{i,j-1} - T_{i-1,j-1}}{4^j-1}
$$</p>
<p>其中 $R_{i,j}$ 表示将区间 $[a,b]$ 分成 $2^j$ 个小区间，对第 $i$ 个小区间使用龙贝格算法所得到的积分值。</p>
<h3 id="443-龙贝格算法">4.4.3. 龙贝格算法</h3>
<p>龙贝格算法的具体步骤如下：</p>
<ol>
<li>根据梯形法的递推公式计算出 $T_{i,0}$；</li>
<li>根据递推公式计算出 $T_{i,j}$，然后使用外推技巧得到 $R_{i,j}$；</li>
<li>判断 $R_{i,j}$ 是否满足精度要求，如果满足则返回 $R_{i,j}$，否则继续计算 $T_{i,j+1}$；</li>
<li>重复步骤 2 和步骤 3，直到满足精度要求或者递归深度达到最大值。</li>
</ol>
<h2 id="45-自适应积分方法">4.5. 自适应积分方法</h2>
<p>自适应积分方法是一种根据函数的特性动态调整积分区间的方法，可以在保持一定精度的前提下大大减少计算量。</p>
<p>具体步骤如下：</p>
<ol>
<li>将整个积分区间 $[a,b]$ 分成两个小区间 $[a,\frac{a+b}{2}]$ 和 $[\frac{a+b}{2},b]$；</li>
<li>分别计算两个小区间上的积分值 $I_1$ 和 $I_2$；</li>
<li>如果 $|I_1+I_2-I|&lt;\epsilon$，其中 $I$ 表示整个积分区间上的积分值，$\epsilon$ 表示精度要求，那么直接返回 $I_1+I_2$；</li>
<li>否则，递归地对两个小区间分别执行步骤 1-3，直到满足精度要求。</li>
</ol>
<h3 id="46-高斯求积公式">4.6. 高斯求积公式</h3>
<p>高斯求积公式是求解定积分的一种数值积分方法，其基本思想是通过选取一些特定的插值节点和权重系数，将被积函数在一定区间上的积分转化为对这些节点上函数值的加权求和。高斯求积公式的优点在于其精度高、计算简便等特点，因此被广泛应用于数值计算中。</p>
<h4 id="461-一般理论">4.6.1. 一般理论</h4>
<p>设$f(x)$在区间$[a,b]$上可积，$x_1,x_2,&hellip;,x_n$为区间$[a,b]$上的$n$个节点，$w_1,w_2,&hellip;,w_n$为相应的权重系数，则高斯求积公式的一般形式为：</p>
<p>$$\int_a^b f(x)dx ≈ \sum_{i=1}^n w_if(x_i)$$</p>
<p>其中，节点和权重系数的选取是高斯求积公式的关键，一般采用的是在区间$[a,b]$上使得积分精度达到最高的勒让德、切比雪夫等多项式的零点和权重系数。</p>
<h4 id="462-高斯-勒让德求积公式">4.6.2. 高斯-勒让德求积公式</h4>
<p>高斯-勒让德求积公式是在区间$[-1,1]$上使用勒让德多项式的零点和权重系数得到的高斯求积公式。具体来说，设$f(x)$在区间$[-1,1]$上可积，$x_1,x_2,&hellip;,x_n$为勒让德多项式的第$n$个零点，$w_1,w_2,&hellip;,w_n$为相应的权重系数，则高斯-勒让德求积公式的形式为：</p>
<p>$$\int_{-1}^1 f(x)dx ≈ \sum_{i=1}^n w_if(x_i)$$</p>
<p>其中，零点和权重系数的值可以通过递推公式求得。</p>
<p>假设我们已经知道了n-1次的高斯-勒让德求积公式的节点和权重系数，那么可以通过以下递推公式来计算n次的节点和权重系数：</p>
<p>$x_{n} = -\frac{a_{n-1}}{n}x_{n-1} + \sqrt{\frac{2n-1}{n}}$</p>
<p>$a_{n} = \frac{n}{n^2-1}(n-1)a_{n-1}$</p>
<p>其中，$x_n$表示n次求积公式的第i个节点，$a_n$表示n次求积公式中的权重系数，$a_0$为1，$a_1$为0。</p>
<h4 id="463-高斯-切比雪夫求积公式">4.6.3. 高斯-切比雪夫求积公式</h4>
<p>高斯-切比雪夫求积公式是在区间$[-1,1]$上使用切比雪夫多项式的零点和权重系数得到的高斯求积公式。具体来说，设$f(x)$在区间$[-1,1]$上可积，$x_1,x_2,&hellip;,x_n$为切比雪夫多项式的第$n$个零点，$w_1,w_2,&hellip;,w_n$为相应的权重系数，则高斯-切比雪夫求积公式的形式为：</p>
<p>$$\int_{-1}^1 f(x)dx ≈ \frac{\pi}{n}\sum_{i=1}^n w_if(x_i)$$</p>
<p>其中，零点和权重系数的值可以通过公式求得。</p>
<p>对于n阶高斯-切比雪夫求积公式，其零点可以通过以下公式计算：</p>
<p>$x_k=cos(\frac{2k-1}{2n}\pi),\quad k=1,2,&hellip;,n$</p>
<p>其中，$x_k$表示第k个零点。</p>
<p>对于n阶高斯-切比雪夫求积公式，其权重系数可以通过以下公式计算：</p>
<p>$w_k=\frac{\pi}{n},\quad k=1,2,&hellip;,n$</p>
<p>其中，$w_k$表示第k个权重系数。</p>
<h4 id="464-无穷区间的高斯型求积公式">4.6.4. 无穷区间的高斯型求积公式</h4>
<p>对于无穷区间$[a,b]$上的定积分，可以通过使用高斯-拉盖尔求积公式进行求解。</p>
<p>高斯-拉盖尔求积公式是求解定积分的一种数值近似计算方法，它是通过对函数在一定区间上的逼近来实现的。该公式的原理是利用拉盖尔多项式的正交性质，结合高斯求积法得到的权值和节点，来求解函数在一定区间上的定积分近似值。其数学公式如下：</p>
<p>$$\int_{a}^{b}f(x)dx\approx\sum_{i=1}^{n}w_if(x_i)$$</p>
<p>其中，$a$和$b$是积分区间的下限和上限，$n$是节点数，$x_i$是第$i$个节点，$w_i$是对应的权值。</p>
<p>拉盖尔多项式是一类特殊的正交多项式，它们满足以下正交性质：</p>
<p>$$\int_{0}^{\infty} e^{-x} L_n(x) L_m(x)dx = \frac{n!}{n+m} \delta_{nm} $$</p>
<p>其中，$\delta_{nm}$是克罗内克符号，当$n=m$时为1，否则为0。因此，可以利用拉盖尔多项式的正交性质，构造出高斯求积公式来求解函数在一定区间上的定积分。</p>
<p>具体而言，根据高斯求积公式的推导，可以得到节点和权值的表达式：</p>
<p>$$x_i = \frac{b-a}{2}t_i + \frac{a+b}{2}$$</p>
<p>$$w_i = \frac{b-a}{2} \frac{L_n(x_i)}{(1-x_i^2)[L_{n-1}(x_i)]^2}$$</p>
<p>其中，$t_i$是拉盖尔多项式的零点，$L_n(x_i)$是$n$次拉盖尔多项式在$x_i$处的值。由此，我们就可以利用高斯－拉盖尔求积公式，通过节点和权值的计算，来近似求解函数在一定区间上的定积分。</p>
<h3 id="47-多重积分">4.7. 多重积分</h3>
<p>多重积分的数值积分通常采用类似一般数值积分的方法，将积分区域分割成若干小区域，并在每个小区域上进行数值计算，最终将各小区域的计算结果相加得到积分值的近似值。</p>
<p>对于一个二元函数 $f(x,y)$，其在矩形区域 $D=[a,b]\times[c,d]$ 上的二重积分可以表示为：</p>
<p>$$\iint_D f(x,y)\mathrm{d}x\mathrm{d}y$$</p>
<p>其中 $\mathrm{d}x\mathrm{d}y$ 表示在矩形区域上的面积元素。这个二重积分可以通过多种数值积分方法来近似计算，比如矩形法、梯形法、辛普森法等。</p>
<p>矩形法是将积分区域划分成若干小矩形区域，并在每个小矩形区域上计算函数值，最终将所有小矩形的计算结果相加得到积分的近似值。对于一个 $n\times m$ 的矩形区域，可以将其划分成 $n\times m$ 个小矩形区域，每个小矩形的面积为 $\Delta x\Delta y$，其中 $\Delta x=\frac{b-a}{n}$，$\Delta y=\frac{d-c}{m}$。则该二重积分的近似值可以表示为：</p>
<p>$$\iint_D f(x,y)\mathrm{d}x\mathrm{d}y\approx\sum_{i=1}^n\sum_{j=1}^mf(x_i,y_j),\Delta x\Delta y$$</p>
<p>其中 $x_i=a+i\Delta x$，$y_j=c+j\Delta y$。</p>
<p>梯形法是将积分区域划分成若干小梯形区域，并在每个小梯形区域上计算函数值，最终将所有小梯形的计算结果相加得到积分的近似值。对于一个 $n\times m$ 的矩形区域，可以将其划分成 $n\times m$ 个小梯形区域，每个小梯形的面积为 $\frac{\Delta x+\Delta x&rsquo;}{2}\Delta y$ 或 $\frac{\Delta y+\Delta y&rsquo;}{2}\Delta x$，其中 $\Delta x&rsquo;=\frac{(i+1)\Delta x-a}{n}$，$\Delta y&rsquo;=\frac{(j+1)\Delta y-c}{m}$。则该二重积分的近似值可以表示为：</p>
<p>$$\iint_D f(x,y)\mathrm{d}x\mathrm{d}y\approx\sum_{i=1}^n\sum_{j=1}^mf(x_i,y_j),\frac{\Delta x+\Delta x&rsquo;}{2}\Delta y+\sum_{i=1}^n\sum_{j=1}^mf(x_i,y_j),\frac{\Delta y+\Delta y&rsquo;}{2}\Delta x$$</p>
<p>其中 $x_i=a+i\Delta x$，$x_{i+1}=a+(i+1)\Delta x$，$y_j=c+j\Delta y$，$y_{j+1}=c+(j+1)\Delta y$。</p>
<p>辛普森法是将积分区域划分成若干小矩形区域，并在每个小矩形区域上计算函数值，最终将所有小矩形的计算结果相加得到积分的近似值。对于一个 $n\times m$ 的矩形区域，可以将其划分成 $n\times m$ 个小矩形区域，每个小矩形的面积为 $\Delta x\Delta y$，其中 $\Delta x=\frac{b-a}{n}$，$\Delta y=\frac{d-c}{m}$。则该二重积分的近似值可以表示为：</p>
<p>$$\iint_D f(x,y)\mathrm{d}x\mathrm{d}y\approx\frac{\Delta x\Delta y}{9}\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}\left[f(x_i,y_j)+4f(x_i+\frac{\Delta x}{2},y_j)+f(x_{i+1},y_j)+4f(x_i,y_j+\frac{\Delta y}{2})+16f(x_i+\frac{\Delta x}{2},y_j+\frac{\Delta y}{2})+4f(x_{i+1},y_j+\frac{\Delta y}{2})+f(x_i,y_{j+1})+4f(x_i+\frac{\Delta x}{2},y_{j+1})+f(x_{i+1},y_{j+1})\right]$$</p>
<p>其中 $x_i=a+i\Delta x$，$x_{i+1}=a+(i+1)\Delta x$，$y_j=c+j\Delta y$，$y_{j+1}=c+(j+1)\Delta y$。</p>
<h3 id="48-数值微分">4.8. 数值微分</h3>
<p>数值微分是指通过计算函数在某些点处的导数值来近似计算其导数。常见的数值微分方法包括中点方法、插值型的求导公式、三次样条求导和外推方法等。</p>
<h4 id="481-中点方法与误差分析">4.8.1. 中点方法与误差分析</h4>
<p>中点方法是一种通过计算函数在某一点的前后差商来近似计算其导数的方法。具体来说，对于函数$f(x)$，可以在$x=x_0$处计算其导数值$f&rsquo;(x_0)$的近似值：</p>
<p>$$f&rsquo;(x_0) ≈ \frac{f(x_0+h)-f(x_0-h)}{2h}$$</p>
<p>其中，$h$为步长，$h\to0$时近似值越精确。中点方法的误差可以通过泰勒展开式进行分析，其截断误差为$O(h^2)$。</p>
<h4 id="482-插值型的求导公式">4.8.2. 插值型的求导公式</h4>
<p>插值型的求导公式是一种通过对函数进行插值，并在插值函数的导数上计算某一点的值来近似计算其导数的方法。具体来说，对于函数$f(x)$，可以使用插值函数$P_n(x)$对其进行插值，然后在$P_n&rsquo;(x)$处计算其导数值$f&rsquo;(x_0)$的近似值：</p>
<p>$$f&rsquo;(x_0) ≈ P_n&rsquo;(x_0)$$</p>
<p>其中，$f&rsquo;(x)$表示原函数在$x$处的导数，$P_n&rsquo;(x)$表示$n$次插值多项式在$x$处的导数。</p>
<p>具体实现中，我们通常采用拉格朗日插值多项式来进行插值计算，其公式为：</p>
<p>$$P_n(x)=\sum_{i=0}^ny_i\prod_{j=0,j\neq i}^n\frac{x-x_j}{x_i-x_j}$$</p>
<p>其中，$y_i$表示函数在$x_i$处的函数值，$x_i$表示插值点的横坐标。</p>
<p>在插值型求导公式中，我们需要对插值多项式进行求导，进而计算得到函数的导数近似值。其公式为：</p>
<p>$$P_n&rsquo;(x)=\sum_{i=0}^ny_i\sum_{j=0,j\neq i}^n\frac{1}{x_i-x_j}\prod_{k=0,k\neq i,k\neq j}^n(x-x_k)$$</p>
<p>通过上述公式，我们可以得到函数在任意给定点处的导数近似值。当$n$越大时，所得到的近似值也会越精确，但同时也需要更多的计算量和内存空间。因此，在实际应用中需要根据具体情况来选择合适的插值次数。</p>
<h4 id="483-三次样条求导">4.8.3. 三次样条求导</h4>
<p>三次样条求导是一种通过对函数进行三次样条插值，并在插值函数的导数上计算某一点的值来近似计算其导数的方法。具体来说，对于函数$f(x)$，可以使用三次样条函数$S(x)$对其进行插值，然后在$S&rsquo;(x_i)$处计算其导数值$f&rsquo;(x_i)$的近似值：</p>
<p>$$f&rsquo;(x_i) ≈ S&rsquo;(x_i) \approx \frac{1}{h_i} (a_i - b_i h_i + c_i h_i^2)$$</p>
<p>其中，$h_i = x_{i+1} - x_i$是数据点间的距离，$a_i=S(x_i)$，$b_i=S&rsquo;(x_i)$，$c_i=S&rsquo;&rsquo;(x_i)/2$是三次多项式的系数。这个近似的导数值与真实的导数值误差较小，当数据点间距离越小时，误差也越小。</p>
<p>三次样条求导的优点在于其插值函数具有良好的光滑性和逼近性，因此可以获得较高的求导精度。</p>
<h4 id="484-数值微分的外推方法">4.8.4. 数值微分的外推方法</h4>
<p>外推方法是一种常用的数值微分方法，其基本思想是利用有限次的数值微分结果来逐步提高精度。例如，可以利用两个较低阶的数值微分结果来推导一个更高阶的结果，从而提高数值微分的精度。外推方法主要有 Richardson 外推法和 Romberg 外推法两种。</p>
<p>以 Richardson 外推法为例，其基本原理是利用两个不同步长的数值微分结果来推导出更高阶的数值微分结果。具体而言，假设我们已经用步长 $h$ 计算了函数 $f(x)$ 的数值微分结果 $D_h[f(x)]$，又用步长 $h/2$ 计算了函数 $f(x)$ 的数值微分结果 $D_{h/2}[f(x)]$，则可以利用下面的公式计算更高阶的数值微分结果，即 $D_{h/4}[f(x)]$：</p>
<p>$$D_{h/4}[f(x)] = \frac{4D_{h/2}[f(x)] - D_h[f(x)]}{3}$$</p>
<p>这个公式的意义是：我们先利用 $h/2$ 步长的数值微分结果来估算出 $h/4$ 步长的数值微分结果，然后通过将 $h/2$ 步长的数值微分结果进行加权平均，再用一个修正系数来调整误差，得到更高阶的 $D_{h/4}[f(x)]$。</p>
<p>类似地，我们可以通过不断迭代这个过程，利用不同步长的数值微分结果来逐步提高精度，从而获得更高阶的数值微分结果。例如，要获得 $D_{h/8}[f(x)]$，我们可以利用 $D_{h/4}[f(x)]$ 和 $D_{h/2}[f(x)]$ 来推导出来。</p>
<p>需要注意的是，外推方法虽然可以提高数值微分的精度，但是也可能出现数值不稳定的情况，例如由于计算机舍入误差或截断误差导致的数值不稳定。因此，在实际应用中需要谨慎选择步长和修正系数等参数，以确保数值微分的精度和稳定性。</p>

</main>


  <footer>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '\\[', right: '\\]', display: true},   
        {left: '$$', right: '$$', display: true},     
        {left: '$', right: '$', display: false},  
        {left: '\\(', right: '\\)', display: false},  
      ],
      throwOnError : false
    });
  });
</script>

  
  <hr/>
  © <a href="http://localhost:5601/blog/">Leocl</a> 2022 &ndash; 2024 | <a href="https://github.com/Leo-cl26">Github</a> | <a href="https://www.zhihu.com/people/mmtumr">ZhiHu</a>
  
  </footer>
  </body>
</html>

<script src="/blog/js/clipboard.js"></script>





